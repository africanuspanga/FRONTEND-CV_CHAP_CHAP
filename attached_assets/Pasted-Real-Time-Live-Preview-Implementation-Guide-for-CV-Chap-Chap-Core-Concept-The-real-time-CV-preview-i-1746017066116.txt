Real-Time Live Preview Implementation Guide for CV Chap Chap
Core Concept
The real-time CV preview in CV Chap Chap uses an iframe-based approach that:

Loads template HTML/CSS into an isolated iframe environment
Injects user data as they type using DOM manipulation
Updates the preview in real-time without page refreshes
Maintains template styling and layout integrity
Here's how to implement this system:

1. Template Renderer Component
// ClientSideTemplateRenderer.tsx
import React, { useEffect, useRef, useState } from 'react';
import { loadTemplateContent } from '@/lib/templates-registry';
interface TemplateRendererProps {
  templateId: string;
  formData: any; // CV form data
  height?: number;
}
const ClientSideTemplateRenderer: React.FC<TemplateRendererProps> = ({ 
  templateId, 
  formData, 
  height = 500 
}) => {
  const iframeRef = useRef<HTMLIFrameElement>(null);
  const [templateHtml, setTemplateHtml] = useState<string>('');
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  // Load template HTML
  useEffect(() => {
    if (!templateId) return;
    
    setLoading(true);
    loadTemplateContent(templateId)
      .then(html => {
        setTemplateHtml(html);
        setLoading(false);
      })
      .catch(err => {
        setError('Failed to load template');
        setLoading(false);
        console.error(err);
      });
  }, [templateId]);
  // Inject data into template whenever formData changes
  useEffect(() => {
    const iframe = iframeRef.current;
    if (!iframe || !iframe.contentWindow || loading || error) return;
    // Wait for iframe to load
    const handleIframeLoad = () => {
      injectDataIntoTemplate();
    };
    // Function to inject data into the template
    const injectDataIntoTemplate = () => {
      try {
        if (!iframe.contentWindow) return;
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        // Inject personal info
        updateElement(iframeDoc, 'first-name', formData.personalInfo.firstName || '');
        updateElement(iframeDoc, 'last-name', formData.personalInfo.lastName || '');
        updateElement(iframeDoc, 'full-name', `${formData.personalInfo.firstName || ''} ${formData.personalInfo.lastName || ''}`.trim());
        updateElement(iframeDoc, 'email', formData.personalInfo.email || '');
        updateElement(iframeDoc, 'phone', formData.personalInfo.phone || '');
        updateElement(iframeDoc, 'location', formData.personalInfo.location || '');
        
        // Inject work experience
        const experienceContainer = iframeDoc.getElementById('experience-container');
        if (experienceContainer && formData.experience && formData.experience.length > 0) {
          experienceContainer.innerHTML = '';
          
          formData.experience.forEach(exp => {
            const expElement = iframeDoc.createElement('div');
            expElement.className = 'experience-item';
            
            // Format date range
            const dateRange = exp.currentlyWorkHere 
              ? `${exp.startDate.month} ${exp.startDate.year} - Present`
              : `${exp.startDate.month} ${exp.startDate.year} - ${exp.endDate?.month || ''} ${exp.endDate?.year || ''}`;
            
            // Build HTML content
            expElement.innerHTML = `
              <h3 class="job-title">${exp.title || ''}</h3>
              <h4 class="company">${exp.company || ''} ${exp.isRemote ? '(Remote)' : ''}</h4>
              <p class="location">${exp.location || ''}</p>
              <p class="dates">${dateRange}</p>
              <div class="responsibilities">
                <ul>
                  ${(exp.responsibilities || []).map(r => `<li>${r}</li>`).join('')}
                </ul>
              </div>
            `;
            
            experienceContainer.appendChild(expElement);
          });
        }
        
        // Similar logic for education, skills, etc.
        // ...
      } catch (err) {
        console.error('Error injecting data into template:', err);
      }
    };
    // Helper function to update an element by ID
    function updateElement(doc: Document, id: string, value: string) {
      const element = doc.getElementById(id);
      if (element) {
        element.textContent = value;
      }
    }
    iframe.addEventListener('load', handleIframeLoad);
    
    // Also trigger data injection when formData changes
    if (iframe.contentDocument?.readyState === 'complete') {
      injectDataIntoTemplate();
    }
    return () => {
      iframe.removeEventListener('load', handleIframeLoad);
    };
  }, [templateHtml, formData, loading, error]);
  if (loading) {
    return <div className="loading-placeholder">Loading template...</div>;
  }
  if (error) {
    return <div className="error-message">{error}</div>;
  }
  return (
    <iframe
      ref={iframeRef}
      srcDoc={templateHtml}
      style={{ 
        width: '100%', 
        height: `${height}px`,
        border: 'none',
        overflow: 'auto'
      }}
      title="CV Preview"
      sandbox="allow-same-origin"
    />
  );
};
export default ClientSideTemplateRenderer;
2. Form Input Components with Real-Time Updates
The key to real-time updates is connecting form inputs to the context state:

// TextInputWithLivePreview.tsx
import React from 'react';
import { Input } from '@/components/ui/input';
import { useCvForm } from '@/contexts/cv-form-context';
interface TextInputProps {
  id: string;
  label: string;
  section: string; // e.g., 'personalInfo'
  field: string;   // e.g., 'firstName'
  placeholder?: string;
  required?: boolean;
}
export const TextInputWithLivePreview: React.FC<TextInputProps> = ({
  id,
  label,
  section,
  field,
  placeholder,
  required = false,
}) => {
  const { formData, updateFormField } = useCvForm();
  
  // Get current value from context
  const value = formData[section]?.[field] || '';
  
  // Handle input change
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    updateFormField(section, field, e.target.value);
  };
  
  return (
    <div className="form-field">
      <label htmlFor={id} className="block text-sm font-medium mb-1">
        {label} {required && <span className="text-red-500">*</span>}
      </label>
      <Input
        id={id}
        value={value}
        onChange={handleChange}
        placeholder={placeholder}
        required={required}
        className="w-full"
      />
    </div>
  );
};
3. CV Form Context for State Management
// cv-form-context.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
// Define form data structure
export interface CVFormData {
  templateId: string;
  personalInfo: {
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    location: string;
    jobTitle: string;
    linkedinUrl: string;
    portfolioUrl: string;
    photoUrl: string;
  };
  experience: Array<{
    title: string;
    company: string;
    location: string;
    startDate: { month: string; year: string };
    endDate?: { month: string; year: string };
    currentlyWorkHere: boolean;
    isRemote: boolean;
    responsibilities: string[];
    achievements: string[];
  }>;
  // Other sections...
}
// Initial empty form state
const initialFormData: CVFormData = {
  templateId: '',
  personalInfo: {
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    location: '',
    jobTitle: '',
    linkedinUrl: '',
    portfolioUrl: '',
    photoUrl: '',
  },
  experience: [],
  // Other sections initialized...
};
interface CVFormContextType {
  formData: CVFormData;
  updateFormField: (section: string, field: string, value: any) => void;
  updateNestedFormField: (section: string, index: number, field: string, value: any) => void;
  // Other methods...
}
const CVFormContext = createContext<CVFormContextType | undefined>(undefined);
export const CVFormProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {
  const [formData, setFormData] = useState<CVFormData>(initialFormData);
  
  // Load saved data from localStorage on initial mount
  useEffect(() => {
    const savedData = localStorage.getItem('cv-form-data');
    if (savedData) {
      try {
        setFormData(JSON.parse(savedData));
      } catch (e) {
        console.error('Failed to parse saved form data', e);
      }
    }
  }, []);
  
  // Save to localStorage whenever form data changes
  useEffect(() => {
    localStorage.setItem('cv-form-data', JSON.stringify(formData));
  }, [formData]);
  
  // Update a simple field
  const updateFormField = (section: string, field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [section]: {
        ...prev[section],
        [field]: value
      }
    }));
  };
  
  // Update a field in a nested array (like experience items)
  const updateNestedFormField = (section: string, index: number, field: string, value: any) => {
    setFormData(prev => {
      const sectionArray = [...prev[section]];
      sectionArray[index] = {
        ...sectionArray[index],
        [field]: value
      };
      return {
        ...prev,
        [section]: sectionArray
      };
    });
  };
  
  const value = {
    formData,
    updateFormField,
    updateNestedFormField,
    // Other methods...
  };
  
  return (
    <CVFormContext.Provider value={value}>
      {children}
    </CVFormContext.Provider>
  );
};
// Custom hook for accessing the context
export const useCvForm = () => {
  const context = useContext(CVFormContext);
  if (context === undefined) {
    throw new Error('useCvForm must be used within a CVFormProvider');
  }
  return context;
};
4. Integration in the Form Workflow
// NewCVCreator.tsx (main form container)
import React from 'react';
import { useCvForm } from '@/contexts/cv-form-context';
import { Card } from '@/components/ui/card';
import ClientSideTemplateRenderer from './ClientSideTemplateRenderer';
import PersonalInfoForm from './steps/PersonalInfoForm';
// Other imports...
const NewCVCreator: React.FC = () => {
  const { formData } = useCvForm();
  
  // Render current step based on state
  const renderCurrentStep = () => {
    // Switch case for different form steps
    // ...
  };
  
  return (
    <div className="container mx-auto p-4">
      <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
        {/* Form area */}
        <div className="lg:col-span-7">
          <Card className="p-6">
            {renderCurrentStep()}
          </Card>
        </div>
        
        {/* Live preview area - only visible on desktop/tablet */}
        {formData.templateId && (
          <div className="hidden lg:block lg:col-span-5 sticky top-4 self-start">
            <Card className="p-4">
              <h3 className="text-lg font-medium mb-2">Live Preview</h3>
              <div className="border rounded overflow-hidden">
                <ClientSideTemplateRenderer
                  templateId={formData.templateId}
                  formData={formData}
                  height={700}
                />
              </div>
            </Card>
          </div>
        )}
      </div>
    </div>
  );
};
5. Performance Optimization Tips
Debounce Input Updates: For fields with frequent typing, debounce updates to prevent rendering lag:
import { debounce } from 'lodash';
// Debounced update function
const debouncedUpdate = debounce((value) => {
  updateFormField(section, field, value);
}, 200); // 200ms delay
// In input handler
const handleChange = (e) => {
  // Update local state immediately for responsive feel
  setLocalValue(e.target.value);
  // Debounce the context update
  debouncedUpdate(e.target.value);
};
Use RequestAnimationFrame for DOM Updates:
const injectDataIntoTemplate = () => {
  requestAnimationFrame(() => {
    try {
      // DOM manipulation code here
    } catch (err) {
      console.error(err);
    }
  });
};
Batch Updates for Complex Sections:
// Instead of updating each field individually
const handleBulkUpdate = (fields) => {
  setFormData(prev => ({
    ...prev,
    experience: prev.experience.map((exp, i) => 
      i === index ? { ...exp, ...fields } : exp
    )
  }));
};
// Then use it for multiple fields at once
handleBulkUpdate({
  title: newTitle,
  company: newCompany,
  location: newLocation
});
By following this implementation pattern, you'll create a seamless real-time preview experience that updates instantly as users input their CV information, providing immediate visual feedback on how their final CV will look.